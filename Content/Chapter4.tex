\chapter{Συγχρονισμός με barriers}
\label{ch:Synchronization with Barriers}
Όπως έχουμε ήδη αναφέρει σε προηγούμενα κεφάλαια, ο προγραμματισμός συστημάτων κοινόχρηστου χώρου διευθύνσεων βασίζεται συνήθως στη χρήση νημάτων, ο συγχρονισμός μεταξύ των οποίων είναι ιδιαίτερα σημαντικός καθώς εξασφαλίζει τη συνέπεια των δεδομένων και την ορθότητα του προγράμματος.

Μία από τις πιο διαδεδομένες μεθόδους συγχρονισμού είναι η \textit{κλήση φραγής}, γνωστή και ως barrier. Όταν στον πηγαίο κώδικα υπάρχει μία κλήση φραγής και συναντηθεί από ένα νήμα, τότε το νήμα περιμένει σε αυτό το σημείο την άφιξη των υπόλοιπων νημάτων, πριν μπορέσουν όλα μαζί να συνεχίσουν την εκτέλεση του κώδικα που ακολουθεί την κλήση φραγής.

%Οι κλήσεις φραγής είναι ιδιαίτερα χρήσιμες για τον διαχωρισμό των φάσεων ενός προγράμματος. Για παράδειγμα, αν θέλουμε να παραλληλοποιήσουμε ένα πρόγραμμα το οποίο υπολογίζει με κάποιο τρόπο τα στοιχεία ενός διδιάστατου πίνακα $A$ (1\textsuperscript{η} φάση) και στη συνέχεια αυτός ο πίνακας χρησιμοποιείται για τον υπολογισμό ενός άλλου πίνακα $B$ (2\textsuperscript{η} φάση), μία κλήση φραγής ανάμεσα στις δύο φάσεις θα εξασφαλίσει ότι πρώτα θα ολοκληρωθεί ο υπολογισμός ολόκληρου του πίνακα $Α$ και μετά θα συνεχίσουν τα νήματα στη δεύτερη φάση. 

Οι κλήσεις φραγής είναι ιδιαίτερα χρήσιμες για τον διαχωρισμό των φάσεων ενός προγράμματος. Για παράδειγμα, αν θέλουμε να παραλληλοποιήσουμε ένα πρόγραμμα το οποίο υλοποιεί μία επαναληπτική μέθοδο (π.χ. conjugate gradient method), θα πρέπει να χρησιμοποιήσουμε κλήση φραγής ανάμεσα στις επαναλήψεις $n$ και $n+1$ ώστε να μην προχωρήσει κάποιο νήμα στην επανάληψη $n+1$ ενώ δεν έχει ολοκληρωθεί ο υπολογισμός της επανάληψης $n$.

%Οι κλήσεις φραγής εκτός από το συγχρονισμόυ νημάτων μπορούν να χρησιμοποιηθούν και για το συγχρονισμό διεργασιών, κάτι που όμως δεν θα μας απασχολήσει στο πλαίσιο της παρούσας διπλωματικής εργασίας.

\section{Υλοποιήσεις barrier}
\label{sec:Barrier Implementations}
Παρόλο που η λογική των κλήσεων φραγής είναι αρκετά απλή, υπάρχει πληθώρα αλγορίθμων για την υλοποίησή τους.

Μία πρώτη κατηγορία κλήσεων φραγής αποτελούν οι κεντρικοποιημένες κλήσεις φραγής (centralized barriers). Κάθε νήμα ενημερώνει μία κοινόχρηστη κατάσταση, ώστε να σημάνει την άφιξη του και έπειτα ελέγχει συνεχώς αυτή την κατάσταση μέχρι να αντιληφθεί ότι έφτασαν όλα τα νήματα. Μόλις φτάσουν όλα τα νήματα, το νήμα συνεχίζει την εκτέλεση του κώδικα που ακολουθεί μετά την κλήση φραγής. Στην πιο απλή της μορφή, η κοινόχρηστη κατάσταση μπορεί να είναι μερικές κοινόχρηστες μεταβλητές που χρησιμοποιούνται για παράδειγμα για τη μέτρηση του πλήθους των νημάτων που αφίχθησαν στον barrier.

Καθώς οι κλήσεις φραγής χρησιμοποιούνται επαναληπτικά, για παράδειγμα όταν υπάρχει ένας barrier στο τέλος ενός βρόγχου \texttt{for}, κατά τη διάρκεια μίας κλήσης τα νήματα θα πρέπει να πραγματοποιήσουν δύο ελέγχους. Έναν έλεγχο που θα εξασφαλίζει ότι όλα τα νήματα έφυγαν από την προηγούμενη κλήση φραγής και έναν έλεγχο που θα εξασφαλίζει ότι όλα τα νήματα έφτασαν στην τρέχουσα κλήση φραγής. Ο έλεγχος για το αν τα νήματα έφυγαν από την προηγούμενη κλήση φραγής είναι απαραίτητος καθώς σε αντίθετη περίπτωση μπορεί να δημιουργηθεί πρόβλημα στο διαχωρισμό δύο διαδοχικών κλήσεων φραγής από κάποιο υποσύνολο των νημάτων. Πιο συγκεκριμένα, όταν υπάρχει μία κοινόχρηστη κατάσταση, υπάρχει η πιθανότητα ένα ή περισσότερα νήματα να εγκλωβιστούν στην προηγούμενη κλήση φραγής, την ώρα που κάποια άλλα έχουν μεταβεί στην επόμενη και ως συνέπεια το πρόγραμμα να οδηγηθεί σε αδιέξοδο (deadlock).

Η λύση για την αποφυγή του διπλού ελέγχου με ταυτόχρονη αποφυγή αδιεξόδου, είναι η εισαγωγή της πληροφορίας \texttt{sense} η οποία παίρνει τιμές \texttt{true} (1) ή \texttt{false} (0). Η πληροφορία \texttt{sense} είναι κοινόχρηστη και η τιμή της αντιστρέφεται μεταξύ δύο διαδοχικών χρήσεων του barrier. Λόγω αυτής της αντιστροφής, η τιμή \texttt{sense} χρησιμοποιείται για το διαχωρισμό μεταξύ διαδοχικών χρήσεων ενός barrier. Η τεχνική αυτή είναι γνωστή ως \textit{sense reversal}, ενώ οι κλήσεις φραγής που τη χρησιμοποιούν είναι γνωστές ως \textit{sense reversing barriers}.

Το μειονέκτημα των κεντρικοποιημένων κλήσεων φραγής είναι οι συνεχόμενες προσβάσεις από όλα τα νήματα σε μία μόνο κοινόχρηστη τοποθεσία. Το πρόβλημα αυτό οδήγησε στην πρόταση υλοποιήσεων που χρησιμοποιούν μεθόδους οπισθοδρόμησης (backoff) όπου ουσιαστικά οι προσβάσεις γίνονται με μεγαλύτερα χρονικά διαστήματα μεταξύ τους. Παράδειγμα μιας τέτοιας μεθόδου αποτελεί η μέθοδος εκθετικής οπισθοδρόμησης (exponential backoff). Αν και με τη χρήση οπισθοδρόμησης παρατηρήθηκε ουσιαστική μείωση της κίνησης στο δίκτυο διασύνδεσης\footnote{Παρατηρήθηκε ταυτόχρονη αύξηση της καθυστέρησης του barrier, δηλαδή του χρόνου μεταξύ της τελευταίας άφιξης και της τελευταίας αναχώρησης από τον barrier.}, δεν επιτυγχάνεται ικανοποιητική κλιμακωσιμότητα των κεντρικοποιημένων κλήσεων φραγής σε μεγάλα συστήματα κάποιων εκατοντάδων επεξεργαστών \cite{mellor1991algorithms}.

Τις συνθήκες υψηλού ανταγωνισμού που υπάρχουν στις κεντρικοποιημένες κλήσεις φραγής μπόρεσε να αντιμετωπίσει ο \textit{combining tree barrier}. Η ιδέα πίσω από αυτή την υλοποίηση είναι η ύπαρξη πολλών μικρών barriers που αποτελούν τους κόμβους-φύλλα μιας δεντρικής δομής δεδομένων και στους οποίους ανατίθενται γνήσια υποσύνολα νημάτων. Κάθε κόμβος τοποθετείται σε διαφορετικά τμήματα μνήμης (memory modules), έτσι ώστε οι προσβάσεις στη μνήμη να μοιράζονται μεταξύ των κόμβων και να μην εστιάζονται σε μία μόνο τοποθεσία όπως συμβαίνει με τους κεντρικοποιημένους barriers. Το τελευταίο νήμα που θα φτάσει σε κάθε barrier-φύλλο (leaf barrier) συνεχίζει διαδίδοντας ενημερώσεις προς τη ρίζα του δέντρου. Όταν κάποιο νήμα καταφέρει να φτάσει στη ρίζα του δέντρου, αυτό σημαίνει ότι όλα τα νήματα που συμμετέχουν στον παράλληλο υπολογισμό έχουν φτάσει στον barrier και η διαδικασία απελευθέρωσής τους από αυτόν μπορεί να ξεκινήσει. Κατά τη διαδικασία απελευθέρωσης, το νήμα που έφτασε στη ρίζα του δέντρου ξεκινά να διαδίδει ενημερώσεις προς τα φύλλα ώστε να επιτραπεί στα νήματα που περιμένουν να συνεχίσουν την εκτέλεση τους.

Ένας παρόμοιος αλγόριθμος με αυτόν του combining tree barrier στον οποίο χρησιμοποιείται δεντρική δομή που έχει τη μορφή δυαδικού δέντρου αποτελεί ο \textit{tournament barrier}. Ο συγχρονισμός μεταξύ των νημάτων πραγματοποιείται μεταξύ δύο νημάτων τη φορά, ενώ το νήμα-εκπρόσωπος που συνεχίζει στο ανώτερο επίπεδο καθορίζεται στατικά και όχι βάσει της σειράς άφιξης, αποφεύγοντας με αυτό τον τρόπο τη χρήση ατομικών εντολών που υλοποιούνται στο υλικό (π.χ. \texttt{fetch\_and\_add()}) και χρησιμοποιούνται από τον combining tree barrier.

Οι παραλλαγές των αλγορίθμων κλήσεων φραγής είναι πάρα πολλές και διαφέρουν άλλες περισσότερο και άλλες λιγότερο μεταξύ τους, ανάλογα με τους στόχους που θέλουν να επιτύχουν αυτοί που τους επινόησαν. Για παράδειγμα, κάποιος μπορεί να προτιμά τη χρήση ή μη ατομικών εντολών που υλοποιούνται στο υλικό (\texttt{fetch\_and\_add()}, \texttt{compare\_and\_swap()} κλπ), τον στατικό ή μη ορισμό των διευθύνσεων μνήμης των κόμβων ενός combining tree barrier, τη χρήση ή μη κλειδαριών (locks) κόκ. Οι διάφορες παραλλαγές στοχεύουν στην επίλυση ζητημάτων που σχετίζονται για παράδειγμα με τις παράλληλες εφαρμογές ή την οργάνωση των υποκείμενων συστημάτων και μπορεί να αφορούν μεταξύ άλλων το πλήθος τον απομακρυσμένων προσβάσεων μνήμης σε συστήματα NUMA, την πολυπλοκότητα χώρου που χρειάζεται ο barrier (π.χ. $O(1)$ για χρήση σταθερού πλήθους κοινόχρηστων μεταβλητών ή $O(N)$ όπου $N$ το πλήθος των νημάτων για χρήση πινάκων με κάθε στοιχείο να αντιστοιχεί σε ένα νήμα) ή το ποσό της κίνησης που δημιουργείται στο δίκτυο διασύνδεσης λόγω των πρωτοκόλλων συνοχής κρυφής μνήμης ανάλογα το είδος αυτών.

\section{Barriers στο OpenMP}
\label{sec:Barriers in OpenMP}
Στη διεπαφή προγραμματισμού εφαρμογών OpenMP που περιγράφηκε στο Κεφάλαιο \ref{ch:OpenMP API}, είδαμε ότι οι κλήσεις φραγής χρησιμοποιούνται ευρέως, τόσο έμμεσα (implicit barrier) στο τέλος παράλληλων περιοχών και των περιοχών διαμοιρασμού εργασίας, όσο και άμμεσα (explicit barrier) μέσω της οδηγίας \texttt{barrier}. Συνεπώς, το πόσο αποδοτική ή όχι είναι η υλοποίηση του barrier μπορεί να έχει σημαντικό αντίκτυπο στην συνολική επίδοση της παράλληλης εφαρμογής. % maybe move to next section

Ενδιαφέρον αποτελεί το γεγονός ότι ο ρόλος των κλήσεων φραγής στα πλαίσια του OpenMP είναι διευρυμένος σε σχέση με τις κλήσεις φραγής που περιγράψαμε μέχρι στιγμής. Αυτό συμβαίνει καθώς ο ρόλος τους εκτός από την επίτευξη συγχρονισμού μεταξύ των νημάτων, περιλαμβάνει και την εξασφάλιση ολοκλήρωσης των εργασιών OpenMP (Υποενότητα \ref{ssec:task directive}), των λεγόμενων και OpenMP tasks ή απλώς tasks, τα οποία δημιουργήθηκαν από την παράλληλη ομάδα. Ένα άλλο χαρακτηριστικό του OpenMP είναι το \textit{cancellation}, δηλαδή η δυνατότητα ακύρωσης της εκτέλεσης μιας περιοχής OpenMP, όπως για παράδειγμα μια παράλληλη περιοχή και η μετάβαση των νημάτων στο τέλος αυτής. Σε περίπτωση που ζητηθεί η ακύρωση της εκτέλεσης μιας παράλληλης περιοχής, τα νήματα επιτρέπεται να μεταβούν στο τέλος της ακόμα και αν δεν έχουν προλάβει να αφιχθούν στην έμμεση κλήση φραγής που βρίσκεται αμέσως πριν αυτό. Οπότε, θα πρέπει οι κλήσεις φραγής που χρησιμοποιούνται στα πλαίσια του OpenMP να υποστηρίζουν την ακύρωση ενός barrier και να επιτρέπουν σε νήματα που έχουν ήδη αφιχθεί να φύγουν από τη διαδικασία αναμονής και να συνεχίσουν την εκτέλεσή τους.

Συνεπώς, οι προϋπάρχοντες αλγόριθμοι κλήσεων φραγής που στοχεύουν μόνο στο συγχρονισμό των νημάτων, είτε θα πρέπει να προσαρμοστούν κατάλληλα για την εξασφάλιση της ολοκλήρωσης των tasks και την υποστήριξη του cancellation, είτε θα πρέπει να επαναδιατυπωθούν από την αρχή για λόγους καλύτερης σχεδίασης, που εν τέλει μπορεί να επηρεάσει την απλότητα και την απόδοση της υλοποίησης.

\section{Ο barrier του OMPi}
\label{sec:OMPi's barrier}
Ο αλγόριθμος του barrier που χρησιμοποιείται στο μεταφραστή OMPi έχει προκύψει μετά από πλήθος βελτιώσεων και επανασχεδιάσεων.

Στην πράξη, ο OMPi διαθέτει τρεις διαφορετικούς αλγορίθμους barrier, καθένας από τους οποίους έχει δύο εκδόσεις. Οι εκδόσεις αυτές χρησιμοποιούνται όταν το cancellation είναι ενεργοποιημένο ή όχι. Για λόγους απλότητας και για ευκολότερη κατανόηση των αλγορίθμων, στα πλαίσια αυτής της διπλωματικής εργασίας θα ασχοληθούμε μόνο με τις εκδόσεις που δεν υποστηρίζουν το cancellation. Επιπλέον, για τους ίδιους λόγους θα παραλειφθούν κάποιες λεπτομέρειες υλοποίησης. Οι τρεις διαφορετικοί τύποι barrier είναι οι εξής:
\begin{itemize}
	\item Parallel Barrier (PB): Χρησιμοποιείται στο τέλος παράλληλων περιοχών και εξασφαλίζει τόσο την ολοκλήρωση της εκτέλεσης των tasks, όσο και το συγχρονισμό των νημάτων.
	\item Default Barrier (DB): Είναι η πιο απλή μορφή barrier που χρησιμοποιείται εντός των παράλληλων περιοχών και εξασφαλίζει μόνο το συγχρονισμό των νημάτων καθώς υποθέτει ότι δεν υπάρχουν tasks. Σε περίπτωση που δημιουργηθούν tasks, τα νήματα μεταβαίνουν σε μια πιο πολύπλοκη μορφή barrier, τον task barrier. 
	\item Task Barrier (TB): Στον barrier αυτό μεταβαίνουν τα νήματα αφού ησέλθουν πρώτα στον default barrier με την προϋπόθεση ότι δημιουργήθηκαν tasks. Εξασφαλίζει τόσο την ολοκλήρωση των tasks, όσο και τον συγχρονισμό των νημάτων.
\end{itemize}

Όλα τα δεδομένα του barrier αποθηκεύονται σε μία μεταβλητή τύπου \texttt{struct} που ονομάζεται \texttt{ort\_defbar\_t} και οι συναρτήσεις διαχείρισης και χρήσης του barrier είναι οι ακόλουθες:

\begin{itemize}
	\item \texttt{ort\_default\_barrier\_init()}: Αρχικοποιεί τον barrier.
	\item \texttt{ort\_default\_barrier\_wait()}: Χρησιμοποιείται από τα νήματα για να συγχρονιστούν στον barrier.
	\item \texttt{ort\_default\_barrier\_destroy()}: Καταστρέφει τον barrier.
\end{itemize}

Η ορολογία \textit{default barrier} που χρησιμοποιείται στις παραπάνω συναρτήσεις αφορά τη χρήση του barrier που παρέχεται από τον OMPi και όχι του barrier που πιθανώς παρέχεται από κάποιο EELIB. Γι' αυτό το λόγο δεν θα πρέπει να συγχέεται με τον ένα από τους τρεις τύπους barrier που παρέχει ο OMPi.

Στη δομή ελέγχου EECB του κάθε νήματος υπάρχει ένας barrier ο οποίος όταν το νήμα δημιουργήσει μια παράλληλη περιοχή, δηλαδή γίνει νήμα-αρχηγός, θα χρησιμοποιηθεί για το συγχρονισμό των νημάτων που συμμετέχουν στην ομάδα. Η αρχικοποίηση του barrier γίνεται στη συνάρτηση \texttt{prepare\_master()} η οποία χρησιμοποιείται για την προετοιμασία του νήματος-αρχηγού για την επικείμενη παράλληλη περιοχή (π.χ. καθορισμός μεγέθους ομάδας, ορισμός της εργασίας που θα εκτελετεί).


\subsection{Βασική αρχιτεκτονική}
\label{ssec:Basic barrier architecture}
Η σχεδίαση των barriers του OMPi βασίζεται σε πίνακες ακεραίων σταθερού μεγέθους (\texttt{MAX\_BAR\_THREADS}\footnote{Τρέχουσα τιμή ίση με 256.}). Κάθε στοιχείο αντιστοιχεί σε ένα μόνο νήμα ώστε να μπορούν να πραγματοποιηθούν προσβάσεις χωρίς τη χρήση κλειδαριών για λόγους αμοιβαίου αποκλεισμού. Με αυτό τον τρόπο, όσο αυξάνεται το πλήθος των νημάτων, ο ανταγωνισμός μεταξύ τους παραμένει ανύπαρκτος. Βέβαια, κάθε πίνακας απαιτεί $O($\texttt{MAX\_BAR\_THREADS}$)$ χώρο, όπου \texttt{MAX\_BAR\_THREADS} το μέγιστο πλήθος των νημάτων που υποστηρίζεται και καθορίζεται κατά το χρόνο μετάφρασης.

Μόλις ένα νήμα φτάσει στον barrier γράφει μία τιμή, έστω 1, στο αντίστοιχο στοιχείο του πίνακα για να σηματοδοτήσει την άφιξή του. Στη συνέχεια, ελέγχει συνεχώς (spins) την τιμή του στοιχείου μέχρι να αλλάξει από 1 σε 0. Αυτό συμβαίνει για όλα τα νήματα, με εξαίρεση το νήμα-αρχηγό (master thread) το οποίο διατρέχει όλες τις θέσεις του πίνακα και ελέγχει αν το αντίστοιχο νήμα έχει φτάσει στον barrier, δηλαδή αν η τιμή του στοιχείου \texttt{arrived[x]} ισούται με 1. Μόλις αντιληφθεί ότι όλα τα νήματα έχουν φτάσει, γράφει σε όλες τις θέσεις του πίνακα την τιμή μηδέν η οποία σηματοδοτεί την απελεθέρωση των νημάτων από τον barrier ώστε να συνεχίσουν την εκτέλεσή τους.

Ο ψευδοκώδικας σε γλώσσα C του αλγορίθμου που περιγράφει τη βασική αρχιτεκτονική του barrier φαίνεται στα Προγράμματα \ref{prg:bsc1} και \ref{prg:bsc2}.

\newpage

\begin{lstlisting}[label=prg:bsc1, caption=Απλός barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
arrived[myid] = 1;          /* Mark me as arrived. */
while (arrived[myid] == 1)  /* Spin until released. */
    ;
\end{lstlisting}

\begin{lstlisting}[label=prg:bsc2, caption=Απλός barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
for every thread (i):
    while (arrived[i] != 1)  /* Wait until thread i arrives */
        ;
        
for every thread (i):
    arrived[i] = 0;  /* Release thread i */
\end{lstlisting}

Ο πίνακας \texttt{arrived} θα πρέπει να έχει αρχικοποιηθεί σε μηδέν κατά την αρχικοποίηση του barrier.


\subsection{Parallel Barrier (PB)}
Ο parallel barrier χρησιμοποιείται αποκλειστικά και μόνο στο τέλος των παράλληλων περιοχών ώστε να εξασφαλίσει τόσο την ολοκλήρωση της εκτέλεσης των tasks, όσο και το συγχρονισμό των νημάτων. Στον barrier αυτό χρησιμοποιούνται δύο πίνακες μεγέθους \texttt{MAX\_BAR\_THREADS} αρχικοποιημένοι στο μηδέν.

Αρχικά, όλα τα νήματα πλην του νήματος-αρχηγού μόλις φτάσουν στον barrier γράφουν την τιμή $2$ στη θέση \texttt{arrived[myid]}, όπου \texttt{myid} το αριθμητικό αναγνωριστικό του εκάστοτε νήματος. Στη συνέχεια περιμένουν μέχρι να αλλάξει η τιμή \texttt{arrived[myid]}, ελέγχοντας παράλληλα για το αν υπάρχουν tasks και σε περίπτωση που υπάρχουν τα εκτελούν. Η διαδικασία ελέγχου για tasks είναι χρονοβόρα καθώς το κάθε νήμα δεν ελέγχει μόνο τη δική του ουρά (queue) για να δει αν υπάρχουν διαθέσιμα tasks προς εκτέλεση, αλλά ελέγχει και τις ουρές όλων των υπόλοιπων νημάτων ώστε να να "κλέψει" ένα task και να το εκτελέσει. Η τεχνική αυτή είναι γνωστή ως \textit{work stealing} και στην περίπτωση των NUMA συστημάτων όπου πραγματοποιούνται απομακρυσμένες προσβάσεις μνήμης, ο χρόνος που απαιτείται για να διεκπεραιωθεί αυξάνεται σημαντικά.

Μόλις φτάσουν όλα τα νήματα στον barrier θα έχει εξασφαλιστεί ο συγχρονισμός, οπότε στη συνέχεια πρέπει να εξασφαλιστεί ότι όλα τα tasks έχουν ολοκληρωθεί. Αυτό γίνεται μέσω ενός δεύτερου σημείου συγχρονισμού, στο οποίο θα περιμένουν τα νήματα αφού ολοκληρώσουν την εκτέλεση των tasks που πιθανώς ανέλαβαν κατά την αναμονή τους στο πρώτο σημείο συγχρονισμού.

Ο ψευδοκώδικας σε γλώσσα C του αλγορίθμου του parallel barrier φαίνεται στα Προγράμματα \ref{prg:pb1} και \ref{prg:pb2}.

\begin{lstlisting}[label=prg:pb1, caption=Parallel barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
/* 1st synchronization point */
arrived[myid] = 2;
while (arrived[myid] == 2)
    if (task_exist)
        check_and_execute_tasks();
    
if (task_exist)
    check_and_execute_tasks();
    
/*2nd synchronization point */
released[myid] = 1;
while (released[myid] == 1)
    ;
\end{lstlisting}


\begin{lstlisting}[label=prg:pb2, caption=Parallel barrier για το νήμα-αρχηγό.]
/* 1st synchronization point */
for every thread (i):
    while (arrived[i] != 2)
        if (task_exist)
            check_and_execute_tasks();
        
for every thread (i):
    arrived[i] = 0;
   
/* 2nd synchronization point */
for every thread (i):
    while (released[i] != 1)
        ;
        
for every thread (i):
    released[i] = 0;
\end{lstlisting}

\newpage

\noindent Είναι σημαντικό να σημειωθούν τα εξής:
\begin{itemize}
	\item Το \texttt{task\_exist} είναι μία μεταβλητή-σημαία (flag) για το αν έχουν φτιαχτεί tasks.
	\item Aνάμεσα στα δύο σημεία συγχρονισμού, υπάρχει ένας ακόμα έλεγχος για tasks. Αυτός ο έλεγχος καλύπτει την περίπτωση στην οποία το τελευταίο νήμα λίγο πριν φτάσει στο πρώτο σημείο συγχρονισμού, έφτιαξε ένα task, το νήμα-αρχηγός είδε ότι όλα τα νήματα έφτασαν στον barrier και ξεκίνησε την απελευθέρωσή τους από το πρώτο σημείο συγχρονισμού, πριν προλάβει κάποιο νήμα να ελέγξει για tasks και να εντοπίσει το νέο task.
	\item Κάθε στοιχείο των πινάκων \texttt{arrived} και \texttt{released} καταλαμβάνει χώρο όσο μία γραμμή\footnote{Cache line ή cache block: Η ποσότητα πληροφορίας που μεταφέρεται μεταξύ κρυφής μνήμης και κύριας μνήμης. Είναι σταθερού μεγέθους και μία τυπική τιμή είναι τα 64 bytes.} της κρυφής μνήμης για την αποφυγή του φαινομένου \textit{false sharing}\footnote{Κατά το φαινόμενο του false sharing, διαφορετικά νήματα ενημερώνουν δεδομένα στην ίδια γραμμή της κρυφής μνήμης, με αποτέλεσμα να δημιουργείται πολύ υψηλή κίνηση στο δίκτυο διασύνδεσης λόγω του πρωτοκόλλου συνοχής κρυφής μνήμης.}. (Ισχύει και για τους τρεις τύπους barrier)
	\item Όσο τα νήματα περιμένουν την απελευθέρωσή τους από το νήμα-αρχηγό, ανά κάποιο σταθερό χρονικό διάστημα, παραχωρούν την προτεραιότητά τους (yield) σε άλλα νήματα ώστε να εκτελεστούν. Το ίδιο συμβαίνει και για το νήμα-αρχηγό όσο περιμένει την άφιξη ενός νήματος στον barrier. (Ισχύει και για τους τρεις τύπους barrier)
\end{itemize}


\subsection{Default Barrier (DB)}
Ο default barrier είναι η πιο απλή μορφή barrier και σε αντίθεση με τον parallel barrier χρησιμοποιείται εντός των παράλληλων περιοχών. Σκοπός του είναι να εξασφαλίσει μόνο το συγχρονισμό των νημάτων καθώς υποθέτει ότι δεν υπάρχουν tasks. Σε περίπτωση όμως που δημιουργηθούν tasks, τα νήματα μεταβαίνουν σε μια πιο πολύπλοκη μορφή barrier, τον task barrier που περιγράφεται στην Υποενότητα \ref{ssec:tb}. 

Ο barrier αυτός είναι σε μεγάλο βαθμό ίδιος με τη βασική αρχιτεκτονική που περιγράφηκε στην Υποενότητα \ref{ssec:Basic barrier architecture}, με τη μόνη διαφορά ότι πραγματοποιεί ελέγχους για την ύπαρξη tasks. Ο έλεγχος για tasks πραγματοποιείται με τον ίδιο τρόπο όπως στον parallel barrier και γι' αυτό δεν θα τον περιγράψουμε περαιτέρω.

Ο ψευδοκώδικας σε γλώσσα C του αλγορίθμου του default barrier φαίνεται στα Προγράμματα \ref{prg:db1} και \ref{prg:db2}.

\begin{lstlisting}[label=prg:db1, caption=Default barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
arrived[myid] = 1;
while (arrived[myid] == 1)
    if (task_exist)
        goto TB;
\end{lstlisting}

\begin{lstlisting}[label=prg:db2, caption=Default barrier για το νήμα-αρχηγό.]
for every thread (i):
    while (arrived[i] != 2)
        if (task_exist)
            goto TB;

if (task_exist)
    goto TB;
     
for every thread (i):
    arrived[i] = 0;
\end{lstlisting}


\subsection{Task Barrier (TB)}
\label{ssec:tb}
Στον task barrier μεταβαίνουν τα νήματα αφού ησέλθουν πρώτα στον default barrier με την προϋπόθεση ότι δημιουργήθηκαν tasks. Εξασφαλίζει τόσο την ολοκλήρωση των tasks, όσο και τον συγχρονισμό των νημάτων.

Αν και παλιότερα ο parallel barrier ήταν πιο απλός από τον task barrier\footnote{Αποτελούνταν από ένα σημείο συγχρονισμού αντί για δύο.}, στην τρέχουσα μορφή τους είναι σχεδόν ίδιοι. Η μόνη διαφορά τους είναι ότι ο parallel barrier πρώτα ελέγχει αν έχουν φτιαχτεί tasks και στη συνέχεια ψάχνει να βρει στις ουρές όλων των νημάτων κάποιο task για να εκτελέσει. Ο task barrier ξεκινάει αμέσως την αναζήτηση για tasks, μιας και ο έλεγχος της μεταβλητής-σημαίας έχει ήδη γίνει στον default barrier.

Ο ψευδοκώδικας σε γλώσσα C του αλγορίθμου του task barrier φαίνεται στα Προγράμματα \ref{prg:tb1} και \ref{prg:tb2}.

\begin{lstlisting}[label=prg:tb1, caption=Task barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
/* 1st synchronization point */
arrived[myid] = 2;
while (arrived[myid] == 2)
    check_and_execute_tasks();
    
check_and_execute_tasks();
    
/*2nd synchronization point */
released[myid] = 1;
while (released[myid] == 1)
    ;
\end{lstlisting}

\begin{lstlisting}[label=prg:tb2, caption=Task barrier για το νήμα-αρχηγό.]
/* 1st synchronization point */
for every thread (i):
    while (arrived[i] != 2)
        check_and_execute_tasks();
        
for every thread (i):
    arrived[i] = 0;
   
/* 2nd synchronization point */
for every thread (i):
    while (released[i] != 1)
        ;
        
for every thread (i):
    released[i] = 0;
\end{lstlisting}


\subsection{Απαιτήσεις μνήμης}
\label{ssec:Memory requirements of OMPi's barrier}
Στο \texttt{struct} \texttt{ort\_defbar\_t} που αποθηκεύονται όλα τα δεδομένα του barrier, υπάρχουν τρεις πίνακες. Οι πίνακες αυτοί είναι οι \texttt{arrived} και \texttt{released} που είδαμε να χρησιμοποιούνται στους τρεις τύπους barrier που αναφέραμε νωρίτερα, καθώς και ο πίνακας \texttt{phase} ο οποίος χρησιμοποιείται για την υλοποίηση της τεχνικής sense reversal που περιγράφηκε στην Ενότητα \ref{sec:Barrier Implementations}. Για λόγους διατήρησης της απλότητας των αλγορίθμων η περιγραφή της τεχνικής αυτής παραλείφθηκε.

Κάθε πίνακας αποτελείται από \texttt{MAX\_BAR\_THREADS} (256) στοιχεία, με κάθε στοιχείο να απαιτεί μέγεθος όσο μία γραμμή της κρυφής μνήμης (128 bytes για αρχιτεκτονική \textit{x86-64} ή για επεξεργαστές που είναι άγνωστη η αρχιτεκτονική τους). Άρα, κάθε πίνακας απαιτεί $256 \times 128 \mbox{B} = 32 \mbox{KiB}$ και συνολικά και οι τρεις πίνακες καταλαμβάνουν $96 \mbox{KiB}$ ή αλλιώς $24$ pages\footnote{Σελίδες εικονικής μνήμης. Mέγεθος στον Linux Kernel: 4096 bytes.}.

Επειδή κάθε νήμα διαθέτει barrier, σε ένα σύστημα NUMA στο οποίο δημιουργείται μία παράλληλη ομάδα με 128 νήματα, μόνο οι barriers απαιτούν $128 \times 96 \mbox{KiB} = 12 \mbox{MiB} = 3073$ pages. Σε ένα μικρό σύστημα τύπου SMP, στο οποίο δημιουργούνται 4 νήματα, οι barriers απαιτούν $4 \times 96 \mbox{KiB} = 96$ pages.

Αν στα παραπάνω συνυπολογιστεί ότι υπάρχει υποστήριξη για πολλαπλές ομάδες και εμφωλευμένο παραλληλισμό, γίνεται εύκολα αντιληπτό ότι οι απαιτήσεις σε μνήμη είναι πραγματικά τεράστιες και πιθανότατα οδηγούν και σε μειωμένες επιδόσεις.

\section{Βελτιστοποίηση απαιτήσεων μνήμης του barrier του OMPi}
Στα πλαίσια αυτής της διπλωματικής εργασίας, έγινε προσπάθεια βελτίωσης του barrier σε συστήματα NUMA. Πριν επικεντρωθούμε στις ιδιαιτερότητες των συστημάτων NUMA, προχωρήσαμε σε κάποιες βελτιώσεις που αφορούν τη μείωση των απαιτήσεων μνήμης ανεξαρτήτως του υποκείμενου συστήματος.

Όπως αναφέρθηκε στην Υποενότητα \ref{ssec:Memory requirements of OMPi's barrier}, οι απαιτήσεις μνήμης του OMPi που σχετίζονται με τον barrier είναι ιδιαίτερα αυξημένες. Οι λόγοι που συμβαίνει αυτό είναι οι εξής:
\begin{itemize}
	\item Ένα τυπικό μέγεθος των γραμμών της κρυφής μνήμης είναι 64 αντί για 128 bytes που χρησιμοποιείται σαν μέγεθος γραμμής από τον OMPi.
	\item Η εκμετάλλευση του διαθέσιμου χώρου μνήμης από τους πίνακες \texttt{arrived}, \texttt{released} και \texttt{phase} δεν είναι η βέλτιστη δυνατή.
	\item Το μέγεθος των πινάκων του barrier είναι σταθερό (\texttt{MAX\_BAR\_THREADS}) και καθορίζεται σε χρόνο μετάφρασης του OMPi. Εκτός αυτού, εμμέσως πλην σαφώς, το μέγιστο πλήθος των νημάτων που συμμετέχουν σε μια παράλληλη ομάδα δεν μπορεί να ξεπεράσει το συγκεκριμένο όριο.
	\item Όλα τα νήματα διαθέτουν μεταβλητή τύπου barrier (\texttt{ort\_defbar\_t}) καθώς αποτελεί πεδίο της δομής ελέχου τους (EECB), ακόμα κι αν δεν γίνουν ποτέ νήματα-αρχηγοί.
\end{itemize}

\noindent Οι βελτιώσεις που έγιναν είναι οι ακόλουθες:
\begin{enumerate}
	\item Το μέγεθος των γραμμών της κρυφής μνήμης από 128 bytes άλλαξε σε 64.
	\item Επειδή κάθε στοιχείο των πινάκων \texttt{arrived}, \texttt{released} και \texttt{phase} πιάνει χώρο όσο μία γραμμή της κρυφής μνήμης, δηλαδή 64 bytes, αλλά χρησιμοποιούνται μόλις τα τέσσερα\footnote{Τυπικό μέγεθος ακεραίου σε συστήματα Linux αρχιτεκτονικής 64-bit.} (4) από αυτά, οι τρεις πίνακες συγχωνεύτηκαν σε έναν. Ο πίνακας αυτός ονομάστηκε \texttt{status}.
	\item Στο EECB του κάθε νήματος αποθηκεύεται δείκτης σε μεταβλητή και όχι μεταβλητή τύπου barrier (\texttt{ort\_defbar\_t}), ενώ η δέσμευση του barrier γίνεται δυναμικά σε χρόνο εκτέλεσης μόνο από τα νήματα-αρχηγούς.
	\item Η δέσμευση του πίνακα \texttt{status} γίνεται δυναμικά ανάλογα το μέγεθος της ομάδας, γεγονός που επιτρέπει πέρα από την εξοικονόμηση μνήμης, την υποστήριξη αυθαίρετου πλήθους νημάτων που συμμετέχουν σε μια παράλληλη ομάδα και όχι το πολύ \texttt{MAX\_BAR\_THREADS} νημάτων.
\end{enumerate}

Σε ένα σύστημα NUMA στο οποίο δημιουργείται μία παράλληλη ομάδα με 128 νήματα οι απαιτήσεις μνήμης σε σελίδες (pages) μετά από κάθε μία από τις παραπάνω βελτιώσεις φαίνονται στον Πίνακα \ref{tab:barrier-mem-optimizations}.

\begin{table}[htbp]
\footnotesize
	\centering
		\begin{tabular}{|c||c|c|c|c|c|}
		\hline
		Α/Α Βελτίωσης & Barriers\footnotemark & Πίνακες/Barrier & Στοιχεία/Πίνακα & Μέγεθος στοιχείου & Σελίδες\footnotemark \\
		\hline \hline
		1 & 128 & 3 & 256 & 64 B & 1536 \\
		\hline
		2 & 128 & 1 & 256 & 64 B & 512 \\
		\hline
		3 & 1 & 1 & 256 & 64 B & 4 \\
		\hline
		4 & 1 & 1 & 128 & 64 B & 2 \\
		\hline
		\end{tabular}
		\caption{Οι απαιτήσεις σε μνήμη του barrier του OMPi μετά από κάθε βελτίωση.}
		\label{tab:barrier-mem-optimizations}
\end{table}
\footnotetext{Συνολικό πλήθος μεταβλητών τύπου barrier (\texttt{ort\_defbar\_t}).}
%\footnotetext{Μέγεθος σε bytes.}
\footnotetext{Συνολικό μέγεθος απαιτήσεων μνήμης σε σελίδες (pages).}

%\begin{itemize}
%	\item 3 πίνακες/barrier * 256 στοιχεία/πίνακα * 64 bytes/στοιχείο * 128 barriers \newline = 6 MiB = 1536 pages
%	\item 1 πίνακα/barrier * 256 στοιχεία/πίνακα * 64 bytes/στοιχείο * 128 barriers \newline = 2 MiB = 512 pages
%	\item 1 πίνακα/barrier * 256 στοιχεία/πίνακα * 64 bytes/στοιχείο * 1 barrier \newline = 16 KiB = 4 pages
%	\item 1 πίνακα/barrier * 128 στοιχεία/πίνακα * 64 bytes/στοιχείο * 1 barrier \newline = 8 KiB = 2 pages
%\end{itemize}

Συνεπώς, ο απαιτούμενος χώρος μνήμης μειώθηκε από τα 12 MiB (3073 pages) στα 8 KiB (2 pages), δηλαδή υπήρξε περίπου μία μείωση της τάξης του $99.93\%$ και η οποία είναι ανεξάρτητη του πλήθους των νημάτων που συμμετέχουν στην παράλληλη ομάδα.


\section{Επανασχεδιασμός του barrier του OMPi για συστήματα NUMA}
Παρόλο που η υλοποίηση του υπάρχοντα barrier του OMPi είναι καλή για σχετικά μικρά συστήματα\footnote{Συστήματα με περίπου το πολύ 32 H/W threads.} τύπου UMA, παρατηρήθηκαν μειωμένες επιδόσεις όσον αφορά μεγαλύτερα συστήματα τύπου NUMA. Όπως ήδη αναφέρθηκε στην Ενότητα \ref{sec:NUMA Systems}, ο αποδοτικός προγραμματισμός των συστημάτων NUMA απαιτεί να εστιάσουμε στην αρχή της τοπικότητας μέσω της εκμετάλλευσης πληροφοριών που σχετίζονται με την τοπολογία του υποκείμενου συστήματος. Για το λόγο αυτό πραγματοποιήθηκε επανασχεδιασμός του αλγορίθμου του barrier που χρησιμοποιείται στον OMPi ώστε να λαμβάνει υπόψιν του την ύπαρξη κόμβων NUMA (ή απλώς κόμβων).

\subsection{Σύντομη περιγραφή}
Πιο συγκεκριμένα, υλοποιήθηκε ένας αλγόριθμος combining tree barrier δύο επιπέδων ο οποίος χρησιμοποιείται σε περίπτωση που τα νήματα μιας παράλληλης ομάδας είναι τοποθετημένα\footnote{Δηλαδή όταν η processor binding policy είναι \texttt{true}, \texttt{close}, \texttt{spread} ή \texttt{master}.} σε δύο ή περισσότερους κόμβους. Σε κάθε κόμβο τοποθετείται ένας barrier-φύλλο (leaf barrier) στον οποίο συγχρονίζονται τα νήματα τα οποία είναι τοποθετημένα στον κόμβο αυτό.

Καθώς ο υπάρχων αλγόριθμος βασίζεται στη χρήση πινάκων, θα πρέπει το κάθε νήμα να αντιστοιχίζεται σε μία μοναδική θέση του πίνακα του barrier. Μέχρι τώρα, η αντιστοίχιση γινόταν βάσει του μοναδικού αναγνωριστικού του κάθε νήματος (EEID - Execution Entity ID) καθώς ο πίνακας ήταν ένας και χρησιμοποιούνταν από όλα τα νήματα. Επειδή όμως στο νέο αλγόριθμο υπάρχουν πολλαπλοί barriers και το πλήθος των νημάτων σε κάθε κόμβο/barrier μπορεί να διαφέρει, θα πρέπει να γίνει αντιστοίχιση του μοναδικού αναγνωριστικού του κάθε νήματος σε ένα τοπικό αναγνωριστικό (LID - Local ID) με ισχύ εντός του κόμβου. Τα τοπικά αναγνωριστικά χρησιμοποιούνται τόσο στους barriers-φύλλα, όσο και στον barrier-ρίζα (root barrier), ενώ οι πιθανές τιμές τους κυμαίνονται στο εύρος $[0,T_n)$. Στην περίπτωση των barrier-φύλλων το $T_n$ αντιστοιχεί στο πλήθος των νημάτων που είναι τοποθετημένα στον κόμβο $n$, ενώ στην περίπτωση του barrier-ρίζα αντιστοιχεί στο πλήθος των κόμβων που χρησιμοποιούνται από την παράλληλη ομάδα.

Υπεύθυνοι για το συγχρονισμό εντός των κόμβων είναι τα νήματα με τοπικό αναγνωριστικό ίσο με μηδέν. Αυτά τα νήματα μπορούν να θεωρηθούν ως νήματα-αρχηγοί στο τοπικό επίπεδο των κόμβων. Αφού επιτευχθεί συγχρονισμός σε επίπεδο κόμβου μέσω του barrier-φύλλου, τα τοπικά νήματα-αρχηγοί συνεχίζουν στο επόμενο επίπεδο μεταβαίνοντας στον barrier-ρίζα ώστε να επιτευχθεί και συγχρονισμός σε επίπεδο συστήματος. Στον barrier-ρίζα υπεύθυνος για το συγχρονισμό είναι το νήμα με μοναδικό αναγνωριστικό (EEID) ίσο με μηδέν. Όταν φτάσουν στον barrier-ρίζα όλα τα νήματα-εκπρόσωποι των κόμβων, έχει επιτευχθεί συγχρονισμός σε επίπεδο συστήματος και ξεκινάει η διαδικασία απελευθέρωσης με κατεύθυνση αντίθετη από αυτή της διαδικασίας άφιξης.

\subsection{Λεπτομέρειες υλοποίησης}
Στα πλαίσια της υλοποίησης χρησιμοποιήθηκε η βιβλιοθήκη \texttt{libnuma} για την ανάκτηση πληροφοριών όπως το πλήθος των διαθέσιμων κόμβων NUMA, την αντιστοίχιση των αριθμητικών αναγνωριστικών των επεξεργαστών στα αριθμητικά αναγνωριστικά των κόμβων στους οποίους υπάγονται, καθώς και τη δέσμευση των μεταβλητών τύπου barrier σε συγκεκριμένους κόμβους με σκοπό την επίτευξη της τοπικότητας.

Αρχικά, κατά την εκκίνηση του συστήματος χρόνου εκτέλεσης του OMPi και υπό την προϋπόθεση ότι η βιβλιοθήκη \texttt{libnuma} είναι διαθέσιμη, πραγματοποείται έλεγχος για την εξακρίβωση των κόμβων στους οποίους επιτρέπεται η δέσμευση μνήμης και για κάθε επεξεργαστή υπολογίζεται και αποθηκεύεται ο κόμβος στον οποίο ανήκει.

Στη συνάρτηση \texttt{prepare\_master()} κατά την οποία προετοιμάζεται το νήμα-αρχηγός για την επικείμενη παράλληλη περιοχή, γίνεται υπολογισμός διάφορων πληροφοριών που θα χρησιμοποιηθούν για την αρχικοποίηση του barrier. Οι πληροφορίες αυτές αφορούν:
\begin{itemize}
	\item Τους κόμβους οι οποίοι θα χρησιμοποιηθούν στην παράλληλη περιοχή που ακολουθεί.
	\item Την ανάθεση τοπικών αναγνωριστικών κάθε νήματος. Ένα τοπικό αναγνωριστικό για τον barrier-φύλλο και ένα για τον barrier-ρίζα.
	\item Το πλήθος των νημάτων που θα τοποθετηθούν σε κάθε κόμβο. 
\end{itemize}

Ο υπολογισμός των κόμβων που θα χρησιμοποιηθούν από μια παράλληλη ομάδα γίνεται με τον ακόλουθο τρόπο. Για κάθε νήμα υπολογίζεται το place στο οποίο θα τοποθετηθεί βάσει του place partition και της processor binding policy που βρίσκεται σε ισχύ στη συγκεκριμένη παράλληλη περιοχή. Στη συνέχεια, χρησιμοποιείται ο πρώτος επεξεργαστής του συγκεκριμένου place για την εύρεση του κόμβου στον οποίο ανήκει.

Ο λόγος που χρησιμοποιείται ο πρώτος επεξεργαστής είναι επειδή θεωρούμε ότι όλοι οι επεξεργαστές ενός place ανήκουν στον ίδιο κόμβο, καθώς στη συνάρτηση \texttt{prepare\_master()} είναι αδύνατο να γνωρίζουμε σε ποιον επεξεργαστή ακριβώς θα τοποθετηθεί το νήμα και συνεπώς ποιος κόμβος θα χρησιμοποιηθεί. Στον OMPi, όταν τα OpenMP places καθορίζονται βάσει αυθαίρετου ονόματος, όλοι οι επεξεργαστές που περιλαμβάνονται σε ένα place ανήκουν στον ίδιο κόμβο. Αν όμως οριστούν μέσω ρητής λίστας από τον χρήστη, υπάρχει η πιθανότητα να δημιουργηθούν places των οποίων οι επεξεργαστές ανήκουν σε διαφορετικούς κόμβους. Σε περίπτωση που το νήμα τοποθετηθεί σε κόμβο διαφορετικό από τον κόμβο του πρώτου επεξεργαστή, ο αλγόριθμος λειτουργεί σωστά με τη μόνη διαφορά ότι θα πραγματοποιούνται απομακρυσμένες προσβάσεις μνήμης για το συγχρονισμό του συγκεκριμένου νήματος.

Αφού υπολογιστούν όλες οι απαραίτητες πληροφορίες που αναφέρθηκαν παραπάνω, πραγματοποιείται έλεγχος για να καθοριστεί αν χρειάζεται η χρήση του combining tree barrier ή απλώς \textit{tree barrier} για συντομία. Αν η επικείμενη παράλληλη ομάδα χρησιμοποιεί δύο ή περισσότερους κόμβους, τότε χρησιμοποιείται ο tree barrier. Σε αντίθετη περίπτωση χρησιμοποιείται ο κλασικός barrier του OMPi που περιγράφηκε στην Ενότητα \ref{sec:OMPi's barrier}.

Η μεταβλητή τύπου δείκτη σε barrier που υπήρχε στη δομή ελέγχου EECB των νημάτων αντικαταστάθηκε με έναν πίνακα δεικτών σε barrier μεγέθους $N+1$, όπου $N$ το πλήθος των διαθέσιμων κόμβων. Οι πρώτοι $N$ δείκτες αντιστοιχούν στους barriers-φύλλα, ενώ ο τελευταίος δείκτης αντιστοιχεί στον barrier-ρίζα. Στη συνάρτηση \texttt{prepare\_master()} δεσμεύεται δυναμικά μνήμη για τον πίνακα δεικτών καθώς και για κάθε barrier, μόνο μία φορά πριν την πρώτη χρήση του. Επίσης, σε κάθε κλήση της αρχικοποιείται ο barrier κάθε κόμβου που πρόκειται να χρησιμοποιηθεί στην παράλληλη περιοχή που ακολουθεί, καθώς και ο barrier-ρίζα.

Στο \texttt{struct} \texttt{ort\_defbar\_t} προστέθηκε το πεδίο \texttt{type} που χρησιμοποιείται για τον καθορισμό του τύπου του barrier και οι πιθανές τιμές είναι:
\begin{itemize}
	\item \texttt{FLAT\_BARRIER}: Για τον κλασικό barrier του OMPi.
	\item \texttt{TREE\_BARRIER\_LOCAL}: Για τους barriers-φύλλα του tree barrier.
	\item \texttt{TREE\_BARRIER\_ROOT}: Για τον barrier-ρίζα του tree barrier.
\end{itemize}

\subsection{Ο αλγόριθμος του νέου barrier}
Κατά την υλοποίηση του combining tree barrier που υλοποιήθηκε στον OMPi, τροποποιήθηκαν οι υπάρχουσες συναρτήσεις. Επειδή οι αλλαγές και στους τρεις τύπους barrier είναι ίδιες λόγω της απόκρυψης των λεπτομερειών υλοποίησης της τεχνικής sense reversal, θα γίνει αναφορά μόνο στον νέο αλγόριθμο ενός τύπου και συγκεκριμένα του default barrier.

Στο νέο αλγόριθμο, ο κώδικας του νήματος-αρχηγού εκτελείται από τα τοπικά νήματα-αρχηγούς. Αφού επιτευχθεί συγχρονισμός σε επίπεδο κόμβου, τα τοπικά νήματα-αρχηγοί μεταβαίνουν στον barrier-ρίζα ώστε να επιτευχθεί και συγχρονισμός σε επίπεδο συστήματος.

Ο ψευδοκώδικας σε γλώσσα C του νέου αλγορίθμου του default barrier φαίνεται στα Προγράμματα \ref{prg:db1-new} και \ref{prg:db2-new}.

\begin{lstlisting}[label=prg:db1-new, caption=Ο νέος default barrier για όλα τα νήματα πλην των τοπικών νημάτων-αρχηγών.]
local_id = (barrier_type == FLAT_BARRIER) ? my_eeid : my_lid;

arrived[local_id] = 1;
while (arrived[local_id] == 1)
    if (task_exist)
        goto TB;
\end{lstlisting}

\newpage

\begin{lstlisting}[label=prg:db2-new, caption=Ο νέος default barrier για τα τοπικά νήματα-αρχηγούς.]
for every thread (i):
    while (arrived[i] != 2)
        if (task_exist)
            goto TB;

if (task_exist)
    goto TB;

/* At this point, inter-node synchronization has been achieved. In case of
 * tree barrier, intra-node synchronization should also take place.
 */
if (barrier_type == TREE_BARRIER_LOCAL)
    goto ROOT_DB;

for every thread (i):
    arrived[i] = 0;
\end{lstlisting}

% Σε αυτό το σημείο χρειάζεται να αναφερθεί ότι ο ψευδοκώδικας στο Πρόγραμμα \ref{prg:db2-new} δεν είναι πλήρης. Επειδή ο default barrier έχει την ιδιαιτερότητα να μεταβαίνει στον task barrier όποτε αυτό είναι απαραίτητο, ...