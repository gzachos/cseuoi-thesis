\chapter{Συγχρονισμός με barriers}
\label{ch:Synchronization with Barriers}
Όπως έχουμε ήδη αναφέρει σε προηγούμενα κεφάλαια, ο προγραμματισμός συστημάτων κοινόχρηστου χώρου διευθύνσεων βασίζεται συνήθως στη χρήση νημάτων, ο συγχρονισμός μεταξύ των οποίων είναι ιδιαίτερα σημαντικός καθώς εξασφαλίζει τη συνέπεια των δεδομένων και την ορθότητα του προγράμματος.

Μία από τις πιο διαδεδομένες μεθόδους συγχρονισμού είναι η \textit{κλήση φραγής}, γνωστή και ως barrier. Όταν στον πηγαίο κώδικα υπάρχει μία κλήση φραγής και συναντηθεί από ένα νήμα, τότε το νήμα περιμένει σε αυτό το σημείο την άφιξη των υπόλοιπων νημάτων, πριν μπορέσουν όλα μαζί να συνεχίσουν την εκτέλεση του κώδικα που ακολουθεί την κλήση φραγής.

%Οι κλήσεις φραγής είναι ιδιαίτερα χρήσιμες για τον διαχωρισμό των φάσεων ενός προγράμματος. Για παράδειγμα, αν θέλουμε να παραλληλοποιήσουμε ένα πρόγραμμα το οποίο υπολογίζει με κάποιο τρόπο τα στοιχεία ενός διδιάστατου πίνακα $A$ (1\textsuperscript{η} φάση) και στη συνέχεια αυτός ο πίνακας χρησιμοποιείται για τον υπολογισμό ενός άλλου πίνακα $B$ (2\textsuperscript{η} φάση), μία κλήση φραγής ανάμεσα στις δύο φάσεις θα εξασφαλίσει ότι πρώτα θα ολοκληρωθεί ο υπολογισμός ολόκληρου του πίνακα $Α$ και μετά θα συνεχίσουν τα νήματα στη δεύτερη φάση. 

Οι κλήσεις φραγής είναι ιδιαίτερα χρήσιμες για τον διαχωρισμό των φάσεων ενός προγράμματος. Για παράδειγμα, αν θέλουμε να παραλληλοποιήσουμε ένα πρόγραμμα το οποίο υλοποιεί μία επαναληπτική μέθοδο (π.χ. Conjugate gradient method), θα πρέπει να χρησιμοποιήσουμε κλήση φραγής ανάμεσα στις επαναλήψεις $n$ και $n+1$ ώστε να μην προχωρήσει κάποιο νήμα στην επανάληψη $n+1$ ενώ δεν έχει ολοκληρωθεί ο υπολογισμός της επανάληψης $n$.

Οι κλήσεις φραγής εκτός από το συγχρονισμόυ νημάτων μπορούν να χρησιμοποιηθούν και για το συγχρονισμό διεργασιών, κάτι που όμως δεν θα μας απασχολήσει στο πλαίσιο της παρούσας διπλωματικής εργασίας.

\section{Υλοποιήσεις barrier}
\label{sec:Barrier Implementations}
Παρόλο που η λογική των κλήσεων φραγής είναι αρκετά απλή, υπάρχει πληθώρα αλγορίθμων για την υλοποίησή τους. 

Μία πρώτη κατηγορία κλήσεων φραγής αποτελούν οι κεντρικοποιημένες κλήσεις φραγής (centralized barriers). Κάθε νήμα ενημερώνει μία κοινόχρηστη κατάσταση, ώστε να σημάνει την άφιξη του και έπειτα ελέγχει συνεχώς αυτή την κατάσταση μέχρι να αντιληφθεί ότι έφτασαν όλα τα νήματα. Μόλις φτάσουν όλα τα νήματα, το νήμα συνεχίζει την εκτέλεση του κώδικα που ακολουθεί μετά την κλήση φραγής. Στην πιο απλή της μορφή, η κοινόχρηστη κατάσταση μπορεί να είναι μερικές κοινόχρηστες μεταβλητές που χρησιμοποιούνται για παράδειγμα για τη μέτρηση του πλήθους των νημάτων που αφίχθησαν στον barrier.

Καθώς οι κλήσεις φραγής χρησιμοποιούνται επαναληπτικά, για παράδειγμα όταν υπάρχει ένας barrier στο τέλος ενός βρόγχου \texttt{for}, κατά τη διάρκεια μίας κλήσης τα νήματα θα πρέπει να πραγματοποιήσουν δύο ελέγχους. Έναν έλεγχο που θα εξασφαλίζει ότι όλα τα νήματα έφυγαν από την προηγούμενη κλήση φραγής και έναν έλεγχο που θα εξασφαλίζει ότι όλα τα νήματα έφτασαν στην τρέχουσα κλήση φραγής. Ο έλεγχος για το αν τα νήματα έφυγαν από την προηγούμενη κλήση φραγής είναι απαραίτητος καθώς σε αντίθετη περίπτωση μπορεί να δημιουργηθεί πρόβλημα στο διαχωρισμό δύο διαδοχικών κλήσεων φραγής από κάποιο γνήσιο υποσύνολο των νημάτων. Πιο συγκεκριμένα, υπάρχει η πιθανότητα ένα ή περισσότερα νήματα να εγκλωβιστούν στην προηγούμενη κλήση φραγής, την ώρα που κάποια άλλα έχουν μεταβεί στην επόμενη και ως συνέπεια το πρόγραμμα να οδηγηθεί σε αδιέξοδο (deadlock).

Η λύση για την αποφυγή του διπλού ελέγχου χωρίς όμως την δυνατότητα οδήγησης σε αδιέξοδο είναι η εισαγωγή της πληροφορίας \texttt{sense} η οποία παίρνει τιμές \texttt{true} (1) ή \texttt{false} (0). Η πληροφορία \texttt{sense} είναι κοινόχρηστη και η τιμή της αντιστρέφεται μεταξύ δύο διαδοχικών χρήσεων του barrier. Λόγω αυτής της αντιστροφής, η τιμή \texttt{sense} χρησιμοποιείται για το διαχωρισμό μεταξύ διαδοχικών χρήσεων ενός barrier. Οι κλήσεις φραγής που χρησιμοποιούν αυτή την τεχνική είναι γνωστές ως \texttt{sense reversing barriers}.

Το μειονέκτημα των κεντρικοποιημένων κλήσεων φραγής είναι οι συνεχόμενες προσβάσεις από όλα τα νήματα σε μία μόνο κοινόχρηστη τοποθεσία. Το πρόβλημα αυτό οδήγησε στην πρόταση υλοποιήσεων που χρησιμοποιούν μεθόδους οπισθοδρόμησης (backoff), όπως για παράδειγμα τη μέθοδο της εκθετικής οπισθοδρόμησης (exponential backoff).  Αν και με τη χρήση οπισθοδρόμησης παρατηρήθηκε ουσιαστική μείωση της κίνησης στο δίκτυο διασύνδεσης\footnote{Παρατηρήθηκε ταυτόχρονη αύξηση της καθυστέρησης του barrier, δηλαδή του χρόνου μεταξύ της τελευταίας άφιξης και της τελευταίας αναχώρησης από τον barrier.}, η κλιμακωσιμότητα των κεντρικοποιημένων κλήσεων φραγής σε μεγάλα συστήματα κάποιων εκατοντάδων επεξεργαστών δεν είναι ικανοποιητική \cite{mellor1991algorithms}.

Τις συνθήκες υψηλού ανταγωνισμού που υπάρχουν στις κεντρικοποιημένες κλήσεις φραγής μπόρεσε να αντιμετωπίσει ο \texttt{combining tree barrier}. Η ιδέα πίσω από αυτή την υλοποίηση είναι η ύπαρξη πολλών μικρών barriers που αποτελούν τους κόμβους-φύλλα μιας δεντρικής δομής δεδομένων και στους οποίους ανατίθενται γνήσια υποσύνολα νημάτων. Κάθε κόμβος τοποθετείται σε διαφορετικά τμήματα μνήμης (memory modules), έτσι ώστε οι προσβάσεις στη μνήμη να μοιράζονται μεταξύ των κόμβων και να μην εστιάζονται σε μία μόνο τοποθεσία όπως συμβαίνει με τους κεντρικοποιημένους barriers. Το τελευταίο νήμα που θα φτάσει σε κάθε barrier-φύλλο (leaf barrier) συνεχίζει διαδίδοντας ενημερώσεις προς τη ρίζα του δέντρου. Όταν κάποιο νήμα καταφέρει να φτάσει στη ρίζα του δέντρου, αυτό σημαίνει ότι όλα τα νήματα που συμμετέχουν στον παράλληλο υπολογισμό έχουν φτάσει στον barrier και η διαδικασία απελευθέρωσής τους από αυτόν μπορεί να ξεκινήσει. Κατά τη διαδικασία απελευθέρωσης, το νήμα που έφτασε στη ρίζα του δέντρου ξεκινά να διαδίδει ενημερώσεις προς τα φύλλα ώστε να επιτραπεί στα νήματα που περιμένουν να συνεχίσουν την εκτέλεση τους.

Ένας παρόμοιος αλγόριθμος με αυτόν του \texttt{combining tree barrier} στον οποίο χρησιμοποιείται δεντρική δομή που έχει τη μορφή δυαδικού δέντρου αποτελεί ο \texttt{tournament barrier}. Ο συγχρονισμός μεταξύ των νημάτων πραγματοποιείται μεταξύ δύο νημάτων τη φορά, ενώ το νήμα-εκπρόσωπος που συνεχίζει στο ανώτερο επίπεδο καθορίζεται στατικά και όχι βάσει της σειράς άφιξης, αποφεύγοντας με αυτό τον τρόπο τη χρήση ατομικών εντολών που υλοποιούνται στο υλικό (π.χ. \texttt{fetch\_and\_add()}) και χρησιμοποιούνται από τον \texttt{combining tree barrier}.

Οι παραλλαγές των αλγορίθμων κλήσεων φραγής είναι πάρα πολλές και διαφέρουν άλλες περισσότερο και άλλες λιγότερο μεταξύ τους, ανάλογα με τους στόχους που θέλουν να επιτύχουν αυτοί που τους επινόησαν. Για παράδειγμα, κάποιος μπορεί να προτιμά τη χρήση ή μη ατομικών εντολών που υλοποιούνται στο υλικό (\texttt{fetch\_and\_add()}, \texttt{compare\_and\_swap()} κλπ), τον στατικό ή μη ορισμό των διευθύνσεων μνήμης των κόμβων ενός \texttt{combining tree barrier}, τη χρήση ή μη κλειδαριών (locks) κόκ. Οι διάφορες παραλλαγές στοχεύουν στην επίλυση ζητημάτων που σχετίζονται για παράδειγμα με τις παράλληλες εφαρμογές ή την οργάνωση των υποκείμενων συστημάτων και μπορεί να αφορούν πλην άλλων το πλήθος τον απομακρυσμένων προσβάσεων μνήμης σε συστήματα NUMA, την πολυπλοκότητα χώρου που χρειάζεται ο barrier (π.χ. $O(1)$ για χρήση σταθερού πλήθους κοινόχρηστων μεταβλητών ή $O(N)$ όπου $N$ το πλήθος των νημάτων για χρήση πινάκων με κάθε στοιχείο να αντιστοιχεί σε ένα νήμα) ή το ποσό της κίνησης που δημιουργείται στο δίκτυο διασύνδεσης λόγω των πρωτοκόλλων συνοχής κρυφής μνήμης ανάλογα το είδος αυτών.

\section{Barriers στο OpenMP}
\label{sec:Barriers in OpenMP}
Στη διεπαφή προγραμματισμού εφαρμογών OpenMP που περιγράφηκε στο Κεφάλαιο \ref{ch:OpenMP API}, είδαμε ότι οι κλήσεις φραγής χρησιμοποιούνται ευρέως, τόσο έμμεσα (implicit barrier) στο τέλος παράλληλων περιοχών και των περιοχών διαμοιρασμού εργασίας, όσο και άμμεσα (explicit barrier) μέσω της οδηγίας \texttt{barrier}. Συνεπώς, το πόσο αποδοτική ή όχι είναι η υλοποίηση του barrier μπορεί να έχει σημαντικό αντίκτυπο στην συνολική επίδοση της παράλληλης εφαρμογής. % maybe move to next section

Ενδιαφέρον αποτελεί το γεγονός ότι ο ρόλος των κλήσεων φραγής στα πλαίσια του OpenMP είναι διευρυμένος σε σχέση με τις κλήσεις φραγής που περιγράψαμε μέχρι στιγμής. Αυτό συμβαίνει καθώς ο ρόλος τους εκτός από την επίτευξη συγχρονισμού μεταξύ των νημάτων, περιλαμβάνει και την εξασφάλιση ολοκλήρωσης των εργασιών OpenMP (Υποενότητα \ref{ssec:task directive}), των λεγόμενων και ως OpenMP tasks ή απλώς tasks, τα οποία δημιουργήθηκαν από την παράλληλη ομάδα. Ένα άλλο χαρακτηριστικό του OpenMP είναι το \texttt{cancellation}, δηλαδή η δυνατότητα ακύρωσης της εκτέλεσης μιας περιοχής OpenMP, όπως για παράδειγμα μια παράλληλη περιοχή και η μετάβαση των νημάτων στο τέλος αυτής. Σε περίπτωση που ζητηθεί η ακύρωση της εκτέλεσης μιας παράλληλης περιοχής, τα νήματα επιτρέπεται να μεταβούν στο τέλος της ακόμα και αν δεν έχουν προλάβει να αφιχθούν στην έμμεση κλήση φραγής που βρίσκεται αμέσως πριν αυτό. Οπότε, θα πρέπει οι κλήσεις φραγής που χρησιμοποιούνται στα πλαίσια του OpenMP να υποστηρίζουν την ακύρωση ενός barrier και την επίτρεψη των νημάτων που έχουν ήδη αφιχθεί να αναχωρίσουν από τη διαδικασία αναμονής και να συνεχίσουν την εκτέλεσή τους.

Συνεπώς, οι προϋπάρχοντες αλγόριθμοι κλήσεων φραγής που στοχεύουν μόνο στο συγχρονισμό των νημάτων, είτε θα πρέπει να προσαρμοστούν κατάλληλα για την εξασφάλιση της ολοκλήρωσης των tasks και την υποστήριξη του \texttt{cancellation}, είτε θα πρέπει να επαναδιατυπωθούν από την αρχή για λόγους καλύτερης σχεδίασης, που εν τέλει μπορεί να επηρεάσουν την απλότητα και την απόδοση της υλοποίησης.

\section{Ο barrier του OMPi}
\label{sec:OMPi's barrier}
Ο αλγόριθμος του barrier που χρησιμοποιείται στο μεταφραστή OMPi έχει προκύψει μετά από πλήθος βελτιώσεων και επανασχεδιάσεων.

Στην πράξη, ο OMPi διαθέτει τρεις διαφορετικούς αλγορίθμους barrier, καθένας από τους οποίους έχει δύο εκδόσεις. Οι εκδόσεις αυτές χρησιμοποιούνται όταν το \texttt{cancellation} είναι ενεργοποιημένο ή όχι. Για λόγους απλότητας και για ευκολότερη κατανόηση των αλγορίθμων, στα πλαίσια αυτής της διπλωματικής εργασίας θα ασχοληθούμε μόνο με τις εκδόσεις που δεν υποστηρίζουν το \texttt{cancellation}. Οι τρεις διαφορετικοί τύποι barrier είναι οι εξής:
\begin{itemize}
	\item Parallel Barrier (PB): Χρησιμοποιείται στο τέλος παράλληλων περιοχών και εξασφαλίζει τόσο την ολοκλήρωση της εκτέλεσης των tasks, όσο και το συγχρονισμό των νημάτων.
	\item Default Barrier (DB): Είναι η πιο απλή μορφή barrier που χρησιμοποιείται εντός των παράλληλων περιοχών και εξασφαλίζει μόνο το συγχρονισμό των νημάτων καθώς υποθέτει ότι δεν υπάρχουν tasks. Σε περίπτωση που δημιουργηθούν tasks, τα νήματα μεταβαίνουν σε μια πιο πολύπλοκη μορφή barrier, τον task barrier. 
	\item Task Barrier (TB): Στον barrier αυτό μεταβαίνουν τα νήματα αφού ησέλθουν πρώτα στον default barrier με την προϋπόθεση ότι δημιουργήθηκαν tasks. Εξασφαλίζει τόσο την ολοκλήρωση των tasks, όσο και τον συγχρονισμό των νημάτων.
\end{itemize}

Όλα τα δεδομένα του barrier αποθηκεύονται σε μία μεταβλητή τύπου \texttt{struct} που ονομάζεται \texttt{ort\_defbar\_t} και οι συναρτήσεις διαχείρισης του barrier είναι οι ακόλουθες:

\begin{itemize}
	\item \texttt{ort\_default\_barrier\_init()}: Αρχικοποιεί τον barrier.
	\item \texttt{ort\_default\_barrier\_wait()}: Χρησιμοποιείται από τα νήματα για να συγχρονιστούν στον barrier.
	\item \texttt{ort\_default\_barrier\_destroy()}: Καταστρέφει τον barrier.
\end{itemize}

Η ορολογία default barrier που χρησιμοποιείται στις παραπάνω συναρτήσεις αφορά τη χρήση του barrier που παρέχεται από τον OMPi και όχι του barrier που πιθανώς παρέχεται από κάποιο EELIB. Γι' αυτό το λόγο δεν θα πρέπει να συγχέεται με τον ένα από τους τρεις τύπους barrier που παρέχει ο OMPi.


\subsection{Βασική αρχιτεκτονική}
\label{ssec:Basic barrier architecture}
Η σχεδίαση των barriers του OMPi βασίζεται σε πίνακες ακεραίων σταθερού μεγέθους (\texttt{MAX\_BAR\_THREADS}\footnote{Ισούται με 256.}). Κάθε στοιχείο αντιστοιχεί σε ένα μόνο νήμα ώστε να μπορούν να πραγματοποιηθούν προσβάσεις χωρίς τη χρήση κλειδαριών για λόγους αμοιβαίου αποκλεισμού. Με αυτό τον τρόπο, όσο αυξάνεται το πλήθος των νημάτων, ο ανταγωνισμός μεταξύ τους παραμένει ανύπαρκτος. Βέβαια, κάθε πίνακας απαιτεί $O(MAX\_BAR\_THREADS)$ χώρο, όπου $MAX\_BAR\_THREADS$ το μέγιστο πλήθος των νημάτων που υποστηρίζεται.

Μόλις ένα νήμα φτάσει στον barrier γράφει μία τιμή, έστω 1, στο αντίστοιχο στοιχείο του πίνακα για να σηματοδοτήσει την άφιξή του. Στη συνέχεια, ελέγχει συνεχώς (spins) την τιμή του στοιχείου μέχρι να αλλάξει από άσσο σε μηδέν. Αυτό συμβαίνει για όλα τα νήματα, με εξαίρεση το νήμα-αρχηγό (master thread) το οποίο διατρέχει όλες τις θέσεις του πίνακα και ελέγχει αν το αντίστοιχο νήμα έχει φτάσει στον barrier, δηλαδή αν η τιμή του στοιχείου \texttt{arrived[x]} ισούται με άσσο. Μόλις αντιληφθεί ότι όλα τα νήματα έχουν φτάσει, γράφει σε όλες τις θέσεις του πίνακα την τιμή μηδέν η οποία σηματοδοτεί την απελεθέρωση των νημάτων από τον barrier ώστε να συνεχίσουν την εκτέλεσή τους.

Ο ψευδοκώδικας σε γλώσσα C του αλγορίθμου που περιγράφει τη βασική αρχιτεκτονική του barrier φαίνεται στα Προγράμματα \ref{prg:bsc1} και \ref{prg:bsc2}.

\begin{lstlisting}[label=prg:bsc1, caption=Απλός barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
arrived[myid] = 1;          /* Mark me as arrived. */
while (arrived[myid] == 1)  /* Spin until released. */
    ;
\end{lstlisting}

\begin{lstlisting}[label=prg:bsc2, caption=Απλός barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
for every thread (i):
    while (arrived[i] != 1)  /* Wait until thread i arrives */
        ;
        
for every thread (i):
    arrived[i] = 0;  /* Release thread i */
\end{lstlisting}

Ο πίνακας \texttt{arrived} θα πρέπει να έχει αρχικοποιηθεί σε μηδέν κατά την αρχικοποίηση του barrier.


\subsection{Parallel Barrier (PB)}
Ο parallel barrier χρησιμοποιείται αποκλειστικά και μόνο στο τέλος των παράλληλων περιοχών ώστε να εξασφαλίσει τόσο την ολοκλήρωση της εκτέλεσης των tasks, όσο και το συγχρονισμό των νημάτων. Στον barrier αυτό χρησιμοποιούνται δύο πίνακες μεγέθους \texttt{MAX\_BAR\_THREADS} αρχικοποιημένοι στο μηδέν.

Αρχικά, όλα τα νήματα πλην του νήματος-αρχηγού μόλις φτάσουν στον barrier γράφουν την τιμή $2$ στη θέση \texttt{arrived[myid]}, όπου \texttt{myid} το αριθμητικό αναγνωριστικό του εκάστοτε νήματος. Στη συνέχεια περιμένουν μέχρι να αλλάξει η τιμή \texttt{arrived[myid]}, ελέγχοντας παράλληλα για το αν υπάρχουν tasks και σε περίπτωση που υπάρχουν τα εκτελούν. Η διαδικασία ελέγχου για tasks είναι χρονοβόρα καθώς το κάθε νήμα δεν ελέγχει μόνο τη δική του ουρά (queue) για να δει αν υπάρχουν διαθέσιμα tasks προς εκτέλεση, αλλά ελέγχει και τις ουρές όλων των υπόλοιπων νημάτων ώστε να να "κλέψει" ένα task και να το εκτελέσει. Η τεχνική αυτή είναι γνωστή ως \textit{work stealing} και στην περίπτωση των NUMA συστημάτων όπου πραγματοποιούνται απομακρυσμένες προσβάσεις μνήμης, ο χρόνος που απαιτείται για να διεκπεραιωθεί αυξάνεται σημαντικά.

Μόλις φτάσουν όλα τα νήματα στον barrier θα έχει εξασφαλιστεί ο συγχρονισμός, οπότε στη συνέχεια πρέπει να εξασφαλιστεί ότι όλα τα tasks έχουν ολοκληρωθεί. Αυτό γίνεται μέσω ενός δεύτερου σημείου συγχρονισμού, στο οποίο θα περιμένουν τα νήματα αφού ολοκληρώσουν την εκτέλεση των tasks που πιθανώς ανέλαβαν κατά την αναμονή τους στο πρώτο σημείο συγχρονισμού.

Ο ψευδοκώδικας σε γλώσσα C του αλγορίθμου του parallel barrier φαίνεται στα Προγράμματα \ref{prg:pb1} και \ref{prg:pb2}.

\begin{lstlisting}[label=prg:pb1, caption=Parallel barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
/* 1st synchronization point */
arrived[myid] = 2;
while (arrived[myid] == 2)
    if (task_exist)
        check_and_execute_tasks();
    
if (task_exist)
    check_and_execute_tasks();
    
/*2nd synchronization point */
released[myid] = 1;
while (released[myid] == 1)
    ;
\end{lstlisting}


\begin{lstlisting}[label=prg:pb2, caption=Parallel barrier για το νήμα-αρχηγό.]
/* 1st synchronization point */
for every thread (i):
    while (arrived[i] != 2)
        if (task_exist)
            check_and_execute_tasks();
        
for every thread (i):
    arrived[i] = 0;
   
/* 2nd synchronization point */
for every thread (i):
    while (released[i] != 1)
        ;
        
for every thread (i):
    released[i] = 0;
\end{lstlisting}


\noindent Είναι σημαντικό να σημειωθούν τα εξής:
\begin{itemize}
	\item Το \texttt{task\_exist} είναι μία μεταβλητή-σημαία (flag) για το αν έχουν φτιαχτεί tasks.
	\item Aνάμεσα στα δύο σημεία συγχρονισμού, υπάρχει ένας ακόμα έλεγχος για tasks. Αυτός ο έλεγχος καλύπτει την περίπτωση στην οποία το τελευταίο νήμα λίγο πριν φτάσει στο πρώτο σημείο συγχρονισμού, έφτιαξε ένα task, το νήμα-αρχηγός είδε ότι όλα τα νήματα έφτασαν στον barrier και ξεκίνησε την απελευθέρωσή τους από το πρώτο σημείο συγχρονισμού, πριν προλάβει κάποιο νήμα να ελέγξει για tasks και να εντοπίσει το νέο task.
	\item Κάθε στοιχείο των πινάκων \texttt{arrived} και \texttt{released} καταλαμβάνει χώρο όσο μία γραμμή\footnote{Cache line ή cache block: Η ποσότητα πληροφορίας που μεταφέρεται μεταξύ κρυφής μνήμης και κύριας μνήμης. Είναι σταθερού μεγέθους και μία τυπική τιμή είναι τα 64 bytes.} της κρυφής μνήμης για την αποφυγή του φαινομένου \textit{false sharing}. Κατά το φαινόμενο αυτό, διαφορετικά νήματα ενημερώνουν δεδομένα στην ίδια γραμμή της κρυφής μνήμης, με αποτέλεσμα να δημιουργείται πολύ υψηλή κίνηση στο δίκτυο διασύνδεσης λόγω του πρωτοκόλλου συνοχής κρυφής μνήμης. (Ισχύει και για τους τρεις τύπους barrier)
	\item Όσο τα νήματα περιμένουν την απελευθέρωσή τους από το νήμα-αρχηγό, ανά κάποιο σταθερό χρονικό διάστημα, παραχωρούν την προτεραιότητά τους (yield) σε άλλα νήματα ώστε να εκτελεστούν. Το ίδιο συμβαίνει και για το νήμα-αρχηγό όσο περιμένει την άφιξη ενός νήματος στον barrier. (Ισχύει και για τους τρεις τύπους barrier)
\end{itemize}


\subsection{Default Barrier (DB)}
Ο default barrier είναι η πιο απλή μορφή barrier και σε αντίθεση με τον parallel barrier χρησιμοποιείται εντός των παράλληλων περιοχών. Σκοπός του είναι να εξασφαλίσει μόνο το συγχρονισμό των νημάτων καθώς υποθέτει ότι δεν υπάρχουν tasks. Σε περίπτωση όμως που δημιουργηθούν tasks, τα νήματα μεταβαίνουν σε μια πιο πολύπλοκη μορφή barrier, τον task barrier που περιγράφεται στην Υποενότητα \ref{ssec:tb}. 

Ο barrier αυτός είναι σε μεγάλο βαθμό ίδιος με τη βασική αρχιτεκτονική που περιγράφηκε στην Υποενότητα \ref{ssec:Basic barrier architecture}, με τη μόνη διαφορά ότι πραγματοποιεί ελέγχους για την ύπαρξη tasks. Ο έλεγχος για tasks πραγματοποιείται με τον ίδιο τρόπο όπως στον parallel barrier και γι' αυτό δεν θα τον περιγράψουμε περαιτέρω.

Ο ψευδοκώδικας σε γλώσσα C του αλγορίθμου του task barrier φαίνεται στα Προγράμματα \ref{prg:db1} και \ref{prg:db2}.

\begin{lstlisting}[label=prg:db1, caption=Default barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
arrived[myid] = 1;
while (arrived[myid] == 1)
    if (task_exist)
        goto TB;
\end{lstlisting}

\begin{lstlisting}[label=prg:db2, caption=Default barrier για το νήμα-αρχηγό.]
for every thread (i):
    while (arrived[i] != 2)
        if (task_exist)
            goto TB;

if (task_exist)
    goto TB;
     
for every thread (i):
    arrived[i] = 0;
\end{lstlisting}


\subsection{Task Barrier (TB)}
\label{ssec:tb}
Στον task barrier μεταβαίνουν τα νήματα αφού ησέλθουν πρώτα στον default barrier με την προϋπόθεση ότι δημιουργήθηκαν tasks. Εξασφαλίζει τόσο την ολοκλήρωση των tasks, όσο και τον συγχρονισμό των νημάτων.

Αν και παλιότερα ο parallel barrier ήταν πιο απλός από τον task barrier\footnote{Αποτελούνταν από ένα σημείο συγχρονισμού αντί για δύο.}, στην τρέχουσα μορφή τους είναι σχεδόν ίδιοι. Η μόνη διαφορά τους είναι ότι ο parallel barrier πρώτα ελέγχει αν έχουν φτιαχτεί tasks και στη συνέχεια ψάχνει να βρει στις ουρές όλων των νημάτων κάποιο task για να εκτελέσει. Ο task barrier ξεκινάει αμέσως την αναζήτηση για tasks, μιας και ο έλεγχος της μεταβλητής-σημαίας έχει ήδη γίνει στον default barrier.

Ο ψευδοκώδικας σε γλώσσα C του αλγορίθμου του task barrier φαίνεται στα Προγράμματα \ref{prg:tb1} και \ref{prg:tb2}.

\begin{lstlisting}[label=prg:tb1, caption=Task barrier για όλα τα νήματα πλην του νήματος-αρχηγού.]
/* 1st synchronization point */
arrived[myid] = 2;
while (arrived[myid] == 2)
    check_and_execute_tasks();
    
check_and_execute_tasks();
    
/*2nd synchronization point */
released[myid] = 1;
while (released[myid] == 1)
    ;
\end{lstlisting}

\begin{lstlisting}[label=prg:tb2, caption=Task barrier για το νήμα-αρχηγό.]
/* 1st synchronization point */
for every thread (i):
    while (arrived[i] != 2)
        check_and_execute_tasks();
        
for every thread (i):
    arrived[i] = 0;
   
/* 2nd synchronization point */
for every thread (i):
    while (released[i] != 1)
        ;
        
for every thread (i):
    released[i] = 0;
\end{lstlisting}


\subsection{Απαιτήσεις μνήμης}


\section{Βελτιώσεις που έγιναν στον barrier του OMPi}
\label{sec:Improvements in OMPi's barrier}
Η διπλωματική εργασία περιέχει $\nu$ κεφάλαια.

\subsection{Μείωση απαιτήσεων μνήμης}


\subsection{Βελτιώσεις για NUMA συστήματα}