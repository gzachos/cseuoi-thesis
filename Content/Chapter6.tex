\chapter{Σύνοψη και Μελλοντική Εργασία}

\section{Ανακεφαλαίωση}
Η ανάγκη για όλο και μεγαλύτερη επεξεργαστική ισχύ οδήγησε στη δημιουργία των συστημάτων μη ομοιόμορφης προσπέλασης μνήμης (NUMA), που αποτελούν αρχιτεκτονική εξέλιξη των συμμετρικών πολυεπεξεργαστών (SMPs). Τα συστήματα αυτά παρέχουν κοινόχρηστο χώρο διευθύνσεων και συνεπώς επιτρέπουν τη χρήση διαδεδομένων μοντέλων προγραμματισμού όπως το OpenMP. Λόγω της κατανεμημένης από φυσική άποψη οργάνωση της μνήμης των συστημάτων αυτών, οδηγούμαστε στην εκμετάλλευση πληροφοριών που σχετίζονται με την τοπολογία του υποκείμενου συστήματος για την επίτευξη των βέλτιστων δυνατών επιδόσεων.

Κάτι τέτοιο έρχεται σε αντίθεση με την υψηλού επιπέδου διεπαφή προγραμματισμού εφαρμογών OpenMP, στο πλαίσιο της οποίας χρησιμοποιούνται αφαιρέσεις (abstractions) ώστε να είναι δυνατή η συγγραφή φορητών προγραμμάτων χρήστη. Παρόλα αυτά, λόγω της ανάγκης χρήσης πληροφοριών που σχετίζονται με την τοπολογία του συστήματος, από την έκδοση 4.0 του προτύπου OpenMP και έπειτα, άρχισαν να προδιαγράφονται λειτουργίες που σχετίζονται με την τοπολογία του υποκείμενου συστήματος. Οι λειτουργίες αυτές επιτρέπουν τον ορισμό συνόλων επεξεργαστών (OpenMP places) στα οποία μπορούν να ανατεθούν τα νήματα OpenMP βάσει διάφορων πολιτικών, γνωστών ως OpenMP processor binding policies.

Στα πλαίσια της παρούσας διπλωματικής εργασίας, υλοποιήθηκαν πλήρως τα OpenMP places και OpenMP processor binding policies όπως προδιαγράφονται από την πιο πρόσφατη έκδοση του προτύπου OpenMP και συγκεκριμένα την έκδοση 5.1 (Νοέμβριος 2020). Η ικανότητα ελέγχου του τρόπου ανάθεσης των νημάτων σε σύνολα από επεξεργαστές, επιτρέπει τον διαμοιρασμό των νημάτων στους διαθέσιμους επεξεργαστές ανάλογα με τη λογική οργάνωση της εργασίας που πρέπει να επιτελέσει το πρόγραμμα χρήστη. Επιπλέον, μειώθηκαν οι απαιτήσεις χώρου του υπάρχοντα barrier και υλοποιήθηκε ένας νέος αλγόριθμος barrier για τον ερευνητικό μεταφραστή OMPi που υποστηρίζει το OpenMP. Σκοπός του νέου αλγορίθμου ήταν η δυνατότητα συγχρονισμού των νημάτων σε συστήματα NUMA με κλιμακώσιμο τρόπο, καθώς το πλήθος των κόμβων αυξάνεται.

Τα μετροπρογράμματα ελέγχου της ορθότητας της υλοποίησης αλλά και μέτρησης του κόστους σε χρόνο (overhead) που απαιτείται για το συγχρονιμό με χρήση barrier, έδειξαν ότι ο νέος barrier έχει τη δυνατότητα να χρησιμοποιείται αποδοτικά για το συγχρονισμό νημάτων που εκτελούνται σε πολλαπλούς κόμβους NUMA, με ιδιαίτερα ανταγωνιστικές επιδόσεις. Ιδιαίτερα σημαντικό είναι το γεγονός ότι ο νέος αλγόριθμος barrier σε σχέση με τον κλασικό όχι μόνο είναι λιγότερο κοστοβόρος από άποψη χρόνου, αλλά έχει και καλές ιδιότητες κλιμάκωσης, καθώς για κάθε επιπλέον κόμβο που χρησιμοποιείται, το overhead αυξάνεται με μικρό ρυθμό.


\section{Μελλοντική Εργασία}

\subsection{Τοπολογία}
Όπως αναφέρθηκε προηγουμένως, ο κάθε μεταφραστής μετασχηματίζει με διαφορετικό τρόπο τα αφηρημένα ονόματα (π.χ. \texttt{threads}, \texttt{cores}) σε αναγνωριστικά επεξεργαστών. Χαρακτηριστικό παράδειγμα αποτελεί ο GCC ο οποίος στο σύστημα Parade όταν χρησιμοποιηθεί το όνομα \texttt{threads} δημιουργεί το αρχικό place partition τοποθετώντας με κυκλικό τρόπο (round-robin) σε κάθε place ένα H/W thread από κάθε κόμβο. Αυτή η τακτική έχει ως αποτέλεσμα γειτονικά places να περιέχουν επεξεργαστές που ανήκουν σε διαφορετικούς κόμβους NUMA, γεγονός που δυσχεραίνει την ιεραρχική οργάνωση της ανάθεσης των νημάτων, για παράδειγμα, πρώτα σε επίπεδο \texttt{sockets} και έπειτα σε επίπεδο \texttt{threads} εντός του εκάστοτε socket. Αυτό το πρόβλημα το αντιμετωπίσαμε στην πειραματική αξιολόγηση του barrier, όταν η ανάθεση νημάτων σε \texttt{sockets} δεν παρείχε το επιθυμητό επίπεδο ελέγχου καθώς παρατηρήθηκαν μεγάλες διακυμάνσεις και συνεπώς τα OpenMP places έπρεπε να οριστούν ως ρητή λίστα ώστε συνεχόμενα places να ανήκουν στο ίδιο socket. Παρόλο που αυτή η ιεραρχική οργάνωση της ανάθεσης νημάτων σε επεξεργαστές μπορεί να πραγματοποιηθεί χρησιμοποιώντας εμφωλευμένα επίπεδα παραλληλίας, με ότι αυτό συνεπάγεται (π.χ. τροποποίηση κώδικα, επιπλέον κόστος), η εισαγωγή νέων processor binding policies που επιτρέπει αυτού του είδους την ανάθεση χρησιμοποιώντας μόνο ένα επίπεδο παραλληλίας ίσως είναι χρήσιμη και σε άλλα πλαίσια. Για παράδειγμα, όταν \texttt{OMP\_PLACES="sockets($N$)"}, \texttt{OMP\_NUM\_THREADS=$T$} και \texttt{OMP\_PROC\_BIND="close:spread"}\footnote{Το σύμβολο '\texttt{:}' επιλέχθηκε καθώς δεν είναι έγκυρος χαρακτήρας στην τρέχουσα σύνταξη της μεταβλητής \texttt{OMP\_PROC\_BIND}.}, τα $T$ νήματα θα κατανεμηθούν στα $N$ sockets και στη συνέχεια τα $T_n \approx T / N$ που θα τοποθετηθούν στον $N$-οστό κόμβο θα κατανεμηθούν χρησιμοποιώντας την πολιτική \texttt{spread}. Αντί για τη σημειολογία \texttt{<policy>:<policy>} ίσως θα μπορούσαν να χρησιμοποιηθούν και νέα ονόματα πολιτικών.

\subsection{Barriers}
Οι μετρήσεις που πραγματοποιήθηκαν στο πλαίσιο της δοκιμής των barriers έδειξαν την ιδιαίτερη ικανότητα του tree barrier να κλιμακώνει από τους δύο σε περισσότερους κόμβους, συμπεριφορά η οποία διατηρείται ανεξάρτητα από τον τρόπο που ανατίθενται τα νήματα OpenMP σε επεξεργαστές. Όμως, είδαμε ότι ανάλογα το πλήθος των νημάτων που χρησιμοποιούνται ή/και τον τρόπο ανάθεσης αυτών σε επεξεργαστές, οι επιδόσεις του κλασικού barrier του OMPi προσεγγίζουν αυτές του tree barrier και πιθανώς υπό διαφορετικές συνθήκες να είναι καλύτερες. Παράδειγμα μίας τέτοιας περίπτωσης μπορεί να είναι όταν τοποθετείται μόνο ένα νήμα ανά κόμβο και άρα δεν υφίσταται συγχρονισμός στο τοπικό επίπεδο του κόμβου. Για το λόγο αυτό, θα πρέπει να μελετηθούν περαιτέρω οι συνθήκες υπό τις οποίες ο tree barrier υπερέχει του κλασικού barrier και το σύστημα χρόνου εκτέλεσης να αποφασίζει δυναμικά για το ποιόν barrier θα χρησιμοποιήσει. Αυτή τη στιγμή ο tree barrier χρησιμοποιείται όταν χρησιμοποιούνται 2 ή περισσότεροι κόμβοι αλλά θα μπορούσαν να συνεκτιμηθούν και άλλες παράμετροι, όπως για παράδειγμα το πλήθος των νημάτων ανά κόμβο.

Επιπλέον, επειδή το overhead για δύο ή περισσότερους κόμβους καθορίζεται από το ποσό του overhead που εισάγεται κατά τη μετάβαση από έναν σε δύο κόμβους, η βελτίωση του τελευταίου θα καταφέρει να βελτιώσει ακόμα περισσότερο τη συνολική επίδοση του tree barrier καθιστώντας τον ακόμα πιο ανταγωνιστικό.